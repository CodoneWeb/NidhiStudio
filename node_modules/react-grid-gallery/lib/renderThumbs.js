'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var calculateCutOff = function calculateCutOff(len, delta, items) {
  var cutoff = [];
  var cutsum = 0;

  for (var i in items) {
    var item = items[i];
    var fractOfLen = item.scaletwidth / len;
    cutoff[i] = Math.floor(fractOfLen * delta);
    cutsum += cutoff[i];
  }

  var stillToCutOff = delta - cutsum;

  while (stillToCutOff > 0) {
    for (i in cutoff) {
      cutoff[i]++;
      stillToCutOff--;
      if (stillToCutOff < 0) break;
    }
  }

  return cutoff;
};

var buildImageRow = function buildImageRow(data, _ref) {
  var containerWidth = _ref.containerWidth,
      margin = _ref.margin;
  var row = [];
  var len = 0;
  var imgMargin = 2 * margin;

  while (data.items.length > 0 && len < containerWidth) {
    var item = data.items.shift();
    row.push(item);
    len += item.scaletwidth + imgMargin;
  }

  var delta = len - containerWidth;

  if (row.length > 0 && delta > 0) {
    var cutoff = calculateCutOff(len, delta, row);

    for (var i in row) {
      var pixelsToRemove = cutoff[i];
      item = row[i];
      item.marginLeft = -Math.abs(Math.floor(pixelsToRemove / 2));
      item.vwidth = item.scaletwidth - pixelsToRemove;
    }
  } else {
    for (var j in row) {
      item = row[j];
      item.marginLeft = 0;
      item.vwidth = item.scaletwidth;
    }
  }

  return row;
};

var renderThumbs = function renderThumbs(images, _ref2) {
  var containerWidth = _ref2.containerWidth,
      maxRows = _ref2.maxRows,
      rowHeight = _ref2.rowHeight,
      margin = _ref2.margin;
  rowHeight = typeof rowHeight === "undefined" ? 180 : rowHeight;
  margin = typeof margin === "undefined" ? 2 : margin;
  if (!images) return [];
  if (!containerWidth) return [];
  var items = images.slice();
  items = items.map(function (item) {
    return _objectSpread(_objectSpread({}, item), {}, {
      scaletwidth: Math.floor(rowHeight * (item.thumbnailWidth / item.thumbnailHeight))
    });
  });
  var data = {
    items: items
  };
  var thumbs = [];
  var rows = [];

  while (data.items.length > 0) {
    rows.push(buildImageRow(data, {
      containerWidth: containerWidth,
      margin: margin
    }));
  }

  for (var r in rows) {
    for (var i in rows[r]) {
      var item = _objectSpread(_objectSpread({}, rows[r][i]), {}, {
        rowIndex: parseInt(r)
      });

      if (maxRows) {
        if (r < maxRows) {
          thumbs.push(item);
        }
      } else {
        thumbs.push(item);
      }
    }
  }

  return thumbs;
};

module.exports = renderThumbs;
//# sourceMappingURL=renderThumbs.js.map
